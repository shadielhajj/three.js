<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl2 - transformfeedback</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #cccccc;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #050505;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #0080ff;
			}

		</style>
	</head>
	<body>

		<div id="container"></div>
		<div id="info"><a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl2 - transformfeedback</div>

		<script src="../build/three.js"></script>
		<script src="js/controls/OrbitControls.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<!-- Transform feedback vertex shader -->
		<script id="transformVertex" type="x-shader/x-vertex">
			#version 300 es

			in vec3 position;
			in vec3 velocity;
			in vec3 color;

			out vec3 outPosition;
			out vec3 outVelocity;
			out vec3 outColor;

			uniform float deltaTime;
			uniform float time;
			
			#define K_VEL_DECAY 0.99

			vec3 colA = vec3(1.0,1.0,1.0);
			vec3 colB = vec3(1.0,0.0,0.0);

			void main() {

				float uKForce = 150.0;

				// compute force
				//vec3 gravityCenter = vec3(cos(time), sin(time), 0.0) * 10.25;
				vec3 toCenter = - position;
				float toCenterLength = length(toCenter);
				vec3 accel = uKForce * toCenter/(toCenterLength * toCenterLength);

				outPosition = position + velocity * deltaTime;
				outVelocity = velocity * K_VEL_DECAY + accel * deltaTime;
				
				float l = length(position) * 0.01;
				vec3 color = mix(colB, colA, l);
				outColor = color;

			}

		</script>

		<!-- Transform feedback fragment shader. It won't be executed as transform feedback will cancel the rasterizer step -->
		<script id="fragmentNop" type="x-shader/x-fragment">
			#version 300 es
			precision highp float;

			out vec4 fragColor;

			void main() {

				fragColor = vec4( 1.0, 1.0, 1.0, 1.0 );

			}
		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var positions, velocities, colors;

			var camera, scene, renderer, clock;
			var useCPU = false;

			var mesh, transformFeedback;
			var NUM_PARTICLES = 300000;

			init();
			animate();

			function init() {

				clock = new THREE.Clock();

				container = document.getElementById( 'container' );

				//

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3500 );
				camera.position.y = 30;
				camera.position.z = 50;

				controls = new THREE.OrbitControls( camera );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0x050505 );
				scene.fog = new THREE.Fog( 0x050505, 2000, 3500 );

				//

				scene.add( new THREE.AmbientLight( 0x444444 ) );

				//

				var canvas = document.createElement( 'canvas' );
				var context = canvas.getContext( 'webgl2' );

				renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				container.appendChild( renderer.domElement );

				initParticles();
				initTransformFeedback();

				//

				stats = new Stats();
				container.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}


			function initParticles() {

				var geometry = new THREE.BufferGeometry();

				positions = [];
				for ( var i = 0; i < NUM_PARTICLES; i ++ ) {

					// random points on a sphere
					var r = Math.random() * 100.0;
					var angle = Math.random() * Math.PI * 2;
					var angle2 = Math.random() * Math.PI * 2;
					positions.push( r * Math.sin( angle ) * Math.cos( angle2 ),
						r * Math.sin( angle ) * Math.sin( angle2 ),
						r * Math.cos( angle ) 
					);
				}

				colors = new Float32Array( NUM_PARTICLES * 3 );
				velocities = new Float32Array( NUM_PARTICLES * 3 );


				// note: setDynamic( true ) is not needed for transform feedback, but for the processing on the CPU
				geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3, false ).setDynamic( true ) );
				geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ).setDynamic( true ) );
				geometry.addAttribute( 'velocity', new THREE.Float32BufferAttribute( velocities, 3, false ).setDynamic( true ) );

				points = new THREE.Points( geometry, new THREE.PointsMaterial( {
					size: 0.3,
					vertexColors: THREE.VertexColors
				} ) );

				scene.add( points );

			}

			function initTransformFeedback() {

				var material = new THREE.RawShaderMaterial( {
					uniforms: {
						deltaTime: { value: 0.0 },
						time: { value: 0.0 }
					},
					vertexShader: document.getElementById( 'transformVertex' ).textContent.trim(),
					fragmentShader: document.getElementById( 'fragmentNop' ).textContent.trim(),
					transformFeedbackVaryings: {
						outPosition: 'position',
						outVelocity: 'velocity',
						outColor: 'color'
					}
				} );

				transformFeedback = new THREE.WebGLTransformFeedback( material, points, renderer );
			}


			function animate() {

				requestAnimationFrame( animate );

				var delta = clock.getDelta();

				if ( useCPU ) {
					
					processCPU( delta );
				
				} else {

					processTransformFeedback( delta );

				}

				renderer.render( scene, camera );
				stats.update();

			}

			//-----------------------------------------------------------------------
			// Process using transform feedback
			//-----------------------------------------------------------------------

			function processTransformFeedback( delta ) {
					
					// Transform feedback update
					transformFeedback.material.uniforms.deltaTime.value = delta;
					transformFeedback.material.uniforms.time.value += delta;
					transformFeedback.tick();

			}

			//-----------------------------------------------------------------------
			// Process CPU
			//-----------------------------------------------------------------------

			// Auxiliary variables used in processCPU
			var toCenter = new THREE.Vector3();
			var colA = new THREE.Color( 1.0, 1.0, 1.0 );
			var colB = new THREE.Color( 1.0, 0.0, 0.0 );
			var auxPos = new THREE.Vector3();
			var auxVelocity = new THREE.Vector3();
			var K_VEL_DECAY = 0.99;

			function processCPU ( delta ) {

				var positions = points.geometry.attributes.position.array;
				var colors = points.geometry.attributes.color.array;
				var velocities = points.geometry.attributes.velocity.array;

				for (var i = 0; i < NUM_PARTICLES; i++ ) {

					auxPosition.set( positions[ 3 * i ], positions[ 3 * i + 1 ], positions[ 3 * i+ 2 ] );
					auxVelocity.set( velocities[ 3 * i ], velocities[ 3 * i + 1 ], velocities[ 3 * i+ 2 ] );

					toCenter.copy( auxPosition ).negate();
					var toCenterLength = toCenter.length();
					var uKForce = 150;
					var accel = toCenter.multiplyScalar( uKForce ).divideScalar( toCenterLength * toCenterLength );

					auxPosition.add( auxVelocity.clone().multiplyScalar( delta ) );
					
					auxVelocity.multiplyScalar( K_VEL_DECAY ).add( accel.multiplyScalar( delta ) );

					positions[ 3 * i ] = auxPosition.x;
					positions[ 3 * i + 1 ] = auxPosition.y;
					positions[ 3 * i + 2 ] = auxPosition.z;

					var l = auxPosition.length() * 0.01;
					var color = colB.clone().lerp( colA, l );

					colors[ 3 * i ] = color.r;
					colors[ 3 * i + 1 ] = color.g;
					colors[ 3 * i + 2 ] = color.b;

					velocities[ 3 * i ] = auxVelocity.x;
					velocities[ 3 * i + 1 ] = auxVelocity.y;
					velocities[ 3 * i + 2 ] = auxVelocity.z;

				}

				points.geometry.attributes.position.needsUpdate = true;
				points.geometry.attributes.color.needsUpdate = true;
				points.geometry.attributes.velocity.needsUpdate = true;
				
			}

		</script>

	</body>
</html>
